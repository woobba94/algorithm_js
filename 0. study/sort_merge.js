// 3.3 병합정렬(Worst와 Best 모두 O(nlogn), 어떤 정렬보다 빠름, 동일 할 수 있음)
// let 입력값 = [5, 10, 66, 77, 54, 32, 11, 15];
// let 정렬된배열 = [];

// 분할(이해를 돕기 위해 8개로 조정)
[5, 10, 66, 77],
  [54, 32, 11, 15][(5, 10)],
  [66, 77],
  [54, 32],
  [11, 15][5],
  [10],
  [66],
  [77],
  [54],
  [32],
  [11],
  [15][
    //정복(0번째끼리 비교!)
    (5, 10)
  ],
  [66, 77],
  [32, 54],
  [11, 15][(5, 10, 66, 77)],
  [11, 15, 32, 54][(5, 10, 11, 15, 32, 54, 66, 77)];

// step 1
let 입력값 = [5, 10, 66, 77, 54, 32, 11, 15];

function 병합정렬(입력배열) {
  let 입력배열의길이 = 입력배열.length;
  if (입력배열의길이 <= 1) {
    return 입력배열;
  }
  let 중간값 = parseInt(입력배열의길이 / 2);
  let 그룹하나 = 병합정렬(입력배열.slice(0, 중간값));
  let 그룹둘 = 병합정렬(입력배열.slice(중간값));
  return `그룹하나 : ${그룹하나} \n 그룹둘 : ${그룹둘}\n\n`;
}

console.log(병합정렬(입력값));

// 3.4 퀵정렬
// 4. 페이지 교체 알고리즘
// 5. 트리와 그래프
// 6. 트리의 순회
